"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _i18n = require("@wordpress/i18n");

var _icons = require("@wordpress/icons");

var _components = require("@wordpress/components");

var _blocks = require("@wordpress/blocks");

var _utils = require("./utils");

var _gap = require("../hooks/gap");

var _useSetting = _interopRequireDefault(require("../components/use-setting"));

var _components2 = require("../components");

var _utils2 = require("../hooks/utils");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
// Used with the default, horizontal flex orientation.
const justifyContentMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center',
  'space-between': 'space-between'
}; // Used with the vertical (column) flex orientation.

const alignItemsMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center'
};
const verticalAlignmentMap = {
  top: 'flex-start',
  center: 'center',
  bottom: 'flex-end'
};
const flexWrapOptions = ['wrap', 'nowrap'];
var _default = {
  name: 'flex',
  label: (0, _i18n.__)('Flex'),
  inspectorControls: function FlexLayoutInspectorControls(_ref) {
    let {
      layout = {},
      onChange,
      layoutBlockSupport = {}
    } = _ref;
    const {
      allowOrientation = true
    } = layoutBlockSupport;
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.Flex, null, (0, _element.createElement)(_components.FlexItem, null, (0, _element.createElement)(FlexLayoutJustifyContentControl, {
      layout: layout,
      onChange: onChange
    })), (0, _element.createElement)(_components.FlexItem, null, allowOrientation && (0, _element.createElement)(OrientationControl, {
      layout: layout,
      onChange: onChange
    }))), (0, _element.createElement)(FlexWrapControl, {
      layout: layout,
      onChange: onChange
    }));
  },
  toolBarControls: function FlexLayoutToolbarControls(_ref2) {
    let {
      layout = {},
      onChange,
      layoutBlockSupport
    } = _ref2;

    if (layoutBlockSupport !== null && layoutBlockSupport !== void 0 && layoutBlockSupport.allowSwitching) {
      return null;
    }

    const {
      allowVerticalAlignment = true
    } = layoutBlockSupport;
    return (0, _element.createElement)(_components2.BlockControls, {
      group: "block",
      __experimentalShareWithChildBlocks: true
    }, (0, _element.createElement)(FlexLayoutJustifyContentControl, {
      layout: layout,
      onChange: onChange,
      isToolbar: true
    }), allowVerticalAlignment && (layout === null || layout === void 0 ? void 0 : layout.orientation) !== 'vertical' && (0, _element.createElement)(FlexLayoutVerticalAlignmentControl, {
      layout: layout,
      onChange: onChange,
      isToolbar: true
    }));
  },
  save: function FlexLayoutStyle(_ref3) {
    var _style$spacing, _style$spacing2;

    let {
      selector,
      layout,
      style,
      blockName
    } = _ref3;
    const {
      orientation = 'horizontal'
    } = layout;
    const blockGapSupport = (0, _useSetting.default)('spacing.blockGap');
    const fallbackValue = (0, _blocks.getBlockSupport)(blockName, ['spacing', 'blockGap', '__experimentalDefault']) || '0.5em';
    const hasBlockGapStylesSupport = blockGapSupport !== null; // If a block's block.json skips serialization for spacing or spacing.blockGap,
    // don't apply the user-defined value to the styles.

    const blockGapValue = style !== null && style !== void 0 && (_style$spacing = style.spacing) !== null && _style$spacing !== void 0 && _style$spacing.blockGap && !(0, _utils2.shouldSkipSerialization)(blockName, 'spacing', 'blockGap') ? (0, _gap.getGapCSSValue)(style === null || style === void 0 ? void 0 : (_style$spacing2 = style.spacing) === null || _style$spacing2 === void 0 ? void 0 : _style$spacing2.blockGap, fallbackValue) : `var( --wp--style--block-gap, ${fallbackValue} )`;
    const justifyContent = justifyContentMap[layout.justifyContent] || justifyContentMap.left;
    const flexWrap = flexWrapOptions.includes(layout.flexWrap) ? layout.flexWrap : 'wrap';
    const verticalAlignment = verticalAlignmentMap[layout.verticalAlignment] || verticalAlignmentMap.center;
    const rowOrientation = `
		flex-direction: row;
		align-items: ${verticalAlignment};
		justify-content: ${justifyContent};
		`;
    const alignItems = alignItemsMap[layout.justifyContent] || alignItemsMap.left;
    const columnOrientation = `
		flex-direction: column;
		align-items: ${alignItems};
		`;
    return (0, _element.createElement)("style", null, `
				${(0, _utils.appendSelectors)(selector)} {
					display: flex;
					flex-wrap: ${flexWrap};
					gap: ${hasBlockGapStylesSupport ? blockGapValue : fallbackValue};
					${orientation === 'horizontal' ? rowOrientation : columnOrientation}
				}

				${(0, _utils.appendSelectors)(selector, '> *')} {
					margin: 0;
				}
			`);
  },

  getOrientation(layout) {
    const {
      orientation = 'horizontal'
    } = layout;
    return orientation;
  },

  getAlignments() {
    return [];
  }

};
exports.default = _default;

function FlexLayoutVerticalAlignmentControl(_ref4) {
  let {
    layout,
    onChange,
    isToolbar = false
  } = _ref4;
  const {
    verticalAlignment = verticalAlignmentMap.center
  } = layout;

  const onVerticalAlignmentChange = value => {
    onChange({ ...layout,
      verticalAlignment: value
    });
  };

  if (isToolbar) {
    return (0, _element.createElement)(_components2.BlockVerticalAlignmentControl, {
      onChange: onVerticalAlignmentChange,
      value: verticalAlignment
    });
  }

  const verticalAlignmentOptions = [{
    value: 'flex-start',
    label: (0, _i18n.__)('Align items top')
  }, {
    value: 'center',
    label: (0, _i18n.__)('Align items center')
  }, {
    value: 'flex-end',
    label: (0, _i18n.__)('Align items bottom')
  }];
  return (0, _element.createElement)("fieldset", {
    className: "block-editor-hooks__flex-layout-vertical-alignment-control"
  }, (0, _element.createElement)("legend", null, (0, _i18n.__)('Vertical alignment')), (0, _element.createElement)("div", null, verticalAlignmentOptions.map((value, icon, label) => {
    return (0, _element.createElement)(_components.Button, {
      key: value,
      label: label,
      icon: icon,
      isPressed: verticalAlignment === value,
      onClick: () => onVerticalAlignmentChange(value)
    });
  })));
}

function FlexLayoutJustifyContentControl(_ref5) {
  let {
    layout,
    onChange,
    isToolbar = false
  } = _ref5;
  const {
    justifyContent = 'left',
    orientation = 'horizontal'
  } = layout;

  const onJustificationChange = value => {
    onChange({ ...layout,
      justifyContent: value
    });
  };

  const allowedControls = ['left', 'center', 'right'];

  if (orientation === 'horizontal') {
    allowedControls.push('space-between');
  }

  if (isToolbar) {
    return (0, _element.createElement)(_components2.JustifyContentControl, {
      allowedControls: allowedControls,
      value: justifyContent,
      onChange: onJustificationChange,
      popoverProps: {
        position: 'bottom right',
        isAlternate: true
      }
    });
  }

  const justificationOptions = [{
    value: 'left',
    icon: _icons.justifyLeft,
    label: (0, _i18n.__)('Justify items left')
  }, {
    value: 'center',
    icon: _icons.justifyCenter,
    label: (0, _i18n.__)('Justify items center')
  }, {
    value: 'right',
    icon: _icons.justifyRight,
    label: (0, _i18n.__)('Justify items right')
  }];

  if (orientation === 'horizontal') {
    justificationOptions.push({
      value: 'space-between',
      icon: _icons.justifySpaceBetween,
      label: (0, _i18n.__)('Space between items')
    });
  }

  return (0, _element.createElement)("fieldset", {
    className: "block-editor-hooks__flex-layout-justification-controls"
  }, (0, _element.createElement)("legend", null, (0, _i18n.__)('Justification')), (0, _element.createElement)("div", null, justificationOptions.map(_ref6 => {
    let {
      value,
      icon,
      label
    } = _ref6;
    return (0, _element.createElement)(_components.Button, {
      key: value,
      label: label,
      icon: icon,
      isPressed: justifyContent === value,
      onClick: () => onJustificationChange(value)
    });
  })));
}

function FlexWrapControl(_ref7) {
  let {
    layout,
    onChange
  } = _ref7;
  const {
    flexWrap = 'wrap'
  } = layout;
  return (0, _element.createElement)(_components.ToggleControl, {
    label: (0, _i18n.__)('Allow to wrap to multiple lines'),
    onChange: value => {
      onChange({ ...layout,
        flexWrap: value ? 'wrap' : 'nowrap'
      });
    },
    checked: flexWrap === 'wrap'
  });
}

function OrientationControl(_ref8) {
  let {
    layout,
    onChange
  } = _ref8;
  const {
    orientation = 'horizontal'
  } = layout;
  return (0, _element.createElement)("fieldset", {
    className: "block-editor-hooks__flex-layout-orientation-controls"
  }, (0, _element.createElement)("legend", null, (0, _i18n.__)('Orientation')), (0, _element.createElement)(_components.Button, {
    label: (0, _i18n.__)('Horizontal'),
    icon: _icons.arrowRight,
    isPressed: orientation === 'horizontal',
    onClick: () => onChange({ ...layout,
      orientation: 'horizontal'
    })
  }), (0, _element.createElement)(_components.Button, {
    label: (0, _i18n.__)('Vertical'),
    icon: _icons.arrowDown,
    isPressed: orientation === 'vertical',
    onClick: () => onChange({ ...layout,
      orientation: 'vertical'
    })
  }));
}
//# sourceMappingURL=flex.js.map