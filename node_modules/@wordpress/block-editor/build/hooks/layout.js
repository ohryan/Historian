"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAttribute = addAttribute;
exports.withLayoutStyles = exports.withInspectorControls = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = require("lodash");

var _compose = require("@wordpress/compose");

var _hooks = require("@wordpress/hooks");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _store = require("../store");

var _components2 = require("../components");

var _useSetting = _interopRequireDefault(require("../components/use-setting"));

var _layout = require("../components/block-list/layout");

var _blockList = _interopRequireDefault(require("../components/block-list"));

var _layouts = require("../layouts");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const layoutBlockSupportKey = '__experimentalLayout';
/**
 * Generates the utility classnames for the given blocks layout attributes.
 * This method was primarily added to reintroduce classnames that were removed
 * in the 5.9 release (https://github.com/WordPress/gutenberg/issues/38719), rather
 * than providing an extensive list of all possible layout classes. The plan is to
 * have the style engine generate a more extensive list of utility classnames which
 * will then replace this method.
 *
 * @param { Array } attributes Array of block attributes.
 *
 * @return { Array } Array of CSS classname strings.
 */

function getLayoutClasses(attributes) {
  var _attributes$layout, _attributes$layout2, _attributes$layout3;

  const layoutClassnames = [];

  if (!attributes.layout) {
    return layoutClassnames;
  }

  if (attributes !== null && attributes !== void 0 && (_attributes$layout = attributes.layout) !== null && _attributes$layout !== void 0 && _attributes$layout.orientation) {
    layoutClassnames.push(`is-${(0, _lodash.kebabCase)(attributes.layout.orientation)}`);
  }

  if (attributes !== null && attributes !== void 0 && (_attributes$layout2 = attributes.layout) !== null && _attributes$layout2 !== void 0 && _attributes$layout2.justifyContent) {
    layoutClassnames.push(`is-content-justification-${(0, _lodash.kebabCase)(attributes.layout.justifyContent)}`);
  }

  if (attributes !== null && attributes !== void 0 && (_attributes$layout3 = attributes.layout) !== null && _attributes$layout3 !== void 0 && _attributes$layout3.flexWrap && attributes.layout.flexWrap === 'nowrap') {
    layoutClassnames.push('is-nowrap');
  }

  return layoutClassnames;
}

function LayoutPanel(_ref) {
  let {
    setAttributes,
    attributes,
    name: blockName
  } = _ref;
  const {
    layout
  } = attributes;
  const defaultThemeLayout = (0, _useSetting.default)('layout');
  const themeSupportsLayout = (0, _data.useSelect)(select => {
    const {
      getSettings
    } = select(_store.store);
    return getSettings().supportsLayout;
  }, []);
  const layoutBlockSupport = (0, _blocks.getBlockSupport)(blockName, layoutBlockSupportKey, {});
  const {
    allowSwitching,
    allowEditing = true,
    allowInheriting = true,
    default: defaultBlockLayout
  } = layoutBlockSupport;

  if (!allowEditing) {
    return null;
  } // Only show the inherit toggle if it's supported,
  // a default theme layout is set (e.g. one that provides `contentSize` and/or `wideSize` values),
  // and that the default / flow layout type is in use, as this is the only one that supports inheritance.


  const showInheritToggle = !!(allowInheriting && !!defaultThemeLayout && (!(layout !== null && layout !== void 0 && layout.type) || (layout === null || layout === void 0 ? void 0 : layout.type) === 'default' || layout !== null && layout !== void 0 && layout.inherit));
  const usedLayout = layout || defaultBlockLayout || {};
  const {
    inherit = false,
    type = 'default'
  } = usedLayout;
  /**
   * `themeSupportsLayout` is only relevant to the `default/flow`
   * layout and it should not be taken into account when other
   * `layout` types are used.
   */

  if (type === 'default' && !themeSupportsLayout) {
    return null;
  }

  const layoutType = (0, _layouts.getLayoutType)(type);

  const onChangeType = newType => setAttributes({
    layout: {
      type: newType
    }
  });

  const onChangeLayout = newLayout => setAttributes({
    layout: newLayout
  });

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components2.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Layout')
  }, showInheritToggle && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.ToggleControl, {
    label: (0, _i18n.__)('Inner blocks use full width'),
    checked: !inherit,
    onChange: () => setAttributes({
      layout: {
        inherit: !inherit
      }
    })
  }), (0, _element.createElement)("p", {
    className: "block-editor-hooks__layout-controls-helptext"
  }, !!inherit ? (0, _i18n.__)('Nested blocks use theme content width with options for full and wide widths.') : (0, _i18n.__)('Nested blocks will fill the width of this container.'))), !inherit && allowSwitching && (0, _element.createElement)(LayoutTypeSwitcher, {
    type: type,
    onChange: onChangeType
  }), !inherit && layoutType && (0, _element.createElement)(layoutType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }))), !inherit && layoutType && (0, _element.createElement)(layoutType.toolBarControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }));
}

function LayoutTypeSwitcher(_ref2) {
  let {
    type,
    onChange
  } = _ref2;
  return (0, _element.createElement)(_components.ButtonGroup, null, (0, _layouts.getLayoutTypes)().map(_ref3 => {
    let {
      name,
      label
    } = _ref3;
    return (0, _element.createElement)(_components.Button, {
      key: name,
      isPressed: type === name,
      onClick: () => onChange(name)
    }, label);
  }));
}
/**
 * Filters registered block settings, extending attributes to include `layout`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function addAttribute(settings) {
  if ((0, _lodash.has)(settings.attributes, ['layout', 'type'])) {
    return settings;
  }

  if ((0, _blocks.hasBlockSupport)(settings, layoutBlockSupportKey)) {
    settings.attributes = { ...settings.attributes,
      layout: {
        type: 'object'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include layout controls
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */


const withInspectorControls = (0, _compose.createHigherOrderComponent)(BlockEdit => props => {
  const {
    name: blockName
  } = props;
  const supportLayout = (0, _blocks.hasBlockSupport)(blockName, layoutBlockSupportKey);
  return [supportLayout && (0, _element.createElement)(LayoutPanel, (0, _extends2.default)({
    key: "layout"
  }, props)), (0, _element.createElement)(BlockEdit, (0, _extends2.default)({
    key: "edit"
  }, props))];
}, 'withInspectorControls');
/**
 * Override the default block element to add the layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

exports.withInspectorControls = withInspectorControls;
const withLayoutStyles = (0, _compose.createHigherOrderComponent)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const shouldRenderLayoutStyles = (0, _blocks.hasBlockSupport)(name, layoutBlockSupportKey);
  const id = (0, _compose.useInstanceId)(BlockListBlock);
  const defaultThemeLayout = (0, _useSetting.default)('layout') || {};
  const element = (0, _element.useContext)(_blockList.default.__unstableElementContext);
  const {
    layout
  } = attributes;
  const {
    default: defaultBlockLayout
  } = (0, _blocks.getBlockSupport)(name, layoutBlockSupportKey) || {};
  const usedLayout = layout !== null && layout !== void 0 && layout.inherit ? defaultThemeLayout : layout || defaultBlockLayout || {};
  const layoutClasses = shouldRenderLayoutStyles ? getLayoutClasses(attributes) : null;
  const className = (0, _classnames.default)(props === null || props === void 0 ? void 0 : props.className, {
    [`wp-container-${id}`]: shouldRenderLayoutStyles
  }, layoutClasses);
  return (0, _element.createElement)(_element.Fragment, null, shouldRenderLayoutStyles && element && (0, _element.createPortal)((0, _element.createElement)(_layout.LayoutStyle, {
    blockName: name,
    selector: `.wp-container-${id}`,
    layout: usedLayout,
    style: attributes === null || attributes === void 0 ? void 0 : attributes.style
  }), element), (0, _element.createElement)(BlockListBlock, (0, _extends2.default)({}, props, {
    className: className
  })));
});
exports.withLayoutStyles = withLayoutStyles;
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/layout/addAttribute', addAttribute);
(0, _hooks.addFilter)('editor.BlockListBlock', 'core/editor/layout/with-layout-styles', withLayoutStyles);
(0, _hooks.addFilter)('editor.BlockEdit', 'core/editor/layout/with-inspector-controls', withInspectorControls);
//# sourceMappingURL=layout.js.map