"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InsertionPointOpenRef = void 0;
exports.default = InsertionPoint;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _data = require("@wordpress/data");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _inserter = _interopRequireDefault(require("../inserter"));

var _store = require("../../store");

var _inbetween = _interopRequireDefault(require("../block-popover/inbetween"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const InsertionPointOpenRef = (0, _element.createContext)();
exports.InsertionPointOpenRef = InsertionPointOpenRef;

function InsertionPointPopover(_ref) {
  let {
    __unstablePopoverSlot,
    __unstableContentRef
  } = _ref;
  const {
    selectBlock,
    hideInsertionPoint
  } = (0, _data.useDispatch)(_store.store);
  const openRef = (0, _element.useContext)(InsertionPointOpenRef);
  const ref = (0, _element.useRef)();
  const {
    orientation,
    previousClientId,
    nextClientId,
    rootClientId,
    isInserterShown
  } = (0, _data.useSelect)(select => {
    var _getBlockListSettings;

    const {
      getBlockOrder,
      getBlockListSettings,
      getBlockInsertionPoint,
      isBlockBeingDragged,
      getPreviousBlockClientId,
      getNextBlockClientId
    } = select(_store.store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);

    if (!order.length) {
      return {};
    }

    let _previousClientId = order[insertionPoint.index - 1];
    let _nextClientId = order[insertionPoint.index];

    while (isBlockBeingDragged(_previousClientId)) {
      _previousClientId = getPreviousBlockClientId(_previousClientId);
    }

    while (isBlockBeingDragged(_nextClientId)) {
      _nextClientId = getNextBlockClientId(_nextClientId);
    }

    return {
      previousClientId: _previousClientId,
      nextClientId: _nextClientId,
      orientation: ((_getBlockListSettings = getBlockListSettings(insertionPoint.rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || 'vertical',
      rootClientId: insertionPoint.rootClientId,
      isInserterShown: insertionPoint === null || insertionPoint === void 0 ? void 0 : insertionPoint.__unstableWithInserter
    };
  }, []);
  const isVertical = orientation === 'vertical';
  const disableMotion = (0, _compose.useReducedMotion)();

  function onClick(event) {
    if (event.target === ref.current && nextClientId) {
      selectBlock(nextClientId, -1);
    }
  }

  function onFocus(event) {
    // Only handle click on the wrapper specifically, and not an event
    // bubbled from the inserter itself.
    if (event.target !== ref.current) {
      openRef.current = true;
    }
  }

  function maybeHideInserterPoint(event) {
    // Only hide the inserter if it's triggered on the wrapper,
    // and the inserter is not open.
    if (event.target === ref.current && !openRef.current) {
      hideInsertionPoint();
    }
  } // Define animation variants for the line element.


  const horizontalLine = {
    start: {
      width: 0,
      top: '50%',
      bottom: '50%',
      x: 0
    },
    rest: {
      width: 4,
      top: 0,
      bottom: 0,
      x: -2
    },
    hover: {
      width: 4,
      top: 0,
      bottom: 0,
      x: -2
    }
  };
  const verticalLine = {
    start: {
      height: 0,
      left: '50%',
      right: '50%',
      y: 0
    },
    rest: {
      height: 4,
      left: 0,
      right: 0,
      y: -2
    },
    hover: {
      height: 4,
      left: 0,
      right: 0,
      y: -2
    }
  };
  const lineVariants = {
    // Initial position starts from the center and invisible.
    start: { ...(!isVertical ? horizontalLine.start : verticalLine.start),
      opacity: 0
    },
    // The line expands to fill the container. If the inserter is visible it
    // is delayed so it appears orchestrated.
    rest: { ...(!isVertical ? horizontalLine.rest : verticalLine.rest),
      opacity: 1,
      borderRadius: '2px',
      transition: {
        delay: isInserterShown ? 0.4 : 0
      }
    },
    hover: { ...(!isVertical ? horizontalLine.hover : verticalLine.hover),
      opacity: 1,
      borderRadius: '2px',
      transition: {
        delay: 0.4
      }
    }
  };
  const inserterVariants = {
    start: {
      scale: disableMotion ? 1 : 0
    },
    rest: {
      scale: 1,
      transition: {
        delay: 0.2
      }
    }
  };
  const className = (0, _classnames.default)('block-editor-block-list__insertion-point', 'is-' + orientation);
  return (0, _element.createElement)(_inbetween.default, {
    previousClientId: previousClientId,
    nextClientId: nextClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  }, (0, _element.createElement)(_components.__unstableMotion.div, {
    layout: !disableMotion,
    initial: disableMotion ? 'rest' : 'start',
    animate: "rest",
    whileHover: "hover",
    whileTap: "pressed",
    exit: "start",
    ref: ref,
    tabIndex: -1,
    onClick: onClick,
    onFocus: onFocus,
    className: (0, _classnames.default)(className, {
      'is-with-inserter': isInserterShown
    }),
    onHoverEnd: maybeHideInserterPoint
  }, (0, _element.createElement)(_components.__unstableMotion.div, {
    variants: lineVariants,
    className: "block-editor-block-list__insertion-point-indicator"
  }), isInserterShown && (0, _element.createElement)(_components.__unstableMotion.div, {
    variants: inserterVariants,
    className: (0, _classnames.default)('block-editor-block-list__insertion-point-inserter')
  }, (0, _element.createElement)(_inserter.default, {
    position: "bottom center",
    clientId: nextClientId,
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    onToggle: isOpen => {
      openRef.current = isOpen;
    },
    onSelectOrClose: () => {
      openRef.current = false;
    }
  }))));
}

function InsertionPoint(_ref2) {
  let {
    children,
    ...props
  } = _ref2;
  const isVisible = (0, _data.useSelect)(select => {
    return select(_store.store).isBlockInsertionPointVisible();
  }, []);
  return (0, _element.createElement)(InsertionPointOpenRef.Provider, {
    value: (0, _element.useRef)(false)
  }, isVisible && (0, _element.createElement)(InsertionPointPopover, props), children);
}
//# sourceMappingURL=insertion-point.js.map